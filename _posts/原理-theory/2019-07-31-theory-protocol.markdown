---
layout: post
title: Socket、tcp、udp、http、https原理
date:  2019-07-31 14:06:00 +0900
description: Socket、tcp、udp、http、https原理
img: post-11.jpg # Add image post (optional)
tags: [原理]
author: # Add name author (optional)
theory: true
---

{{site.label1}} <a href="https://www.leachchen.com/" target="\_blank">https://www.leachchen.com/</a> {{site.label2}}

#### 网络七层模型 ####

| 7 | 应用层 | 例如HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP |

| 6 | 表示层 | 例如XDR、ASN.1、SMB、AFP、NCP |

| 5 | 会话层 | 例如ASAP、TLS、SSH、ISO 8327 / CCITT X.225、RPC、NetBIOS、ASP、Winsock、BSD sockets |

| 4 | 传输层 | 例如TCP、UDP、RTP、SCTP、SPX、ATP、IL |

| 3 | 网络层 | 例如IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、 X.25 |

| 2 | 数据链路层 | 例如以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP |

| 1 | 物理层 | 例如线路、无线电、光纤、信鸽 |


为什么要网络七层模型？应用层、表示层、会话层、传输层（确定数据到达哪个应用）、网络层（确定数据到达哪台计算机）、数据链路层（数据到达计算机网卡）、物理层。以A计算机发送数据hello到B计算机为例

可以思考以下几个问题：

1：A计算机上的数据发送给B计算机的哪个端口上？

2：A计算机如何找到B计算机？

3：数据是如何进入B计算机的？

3：数据最终通过什么到B计算机？

首先A计算机的数据
1：在应用层将消息封装成数据包:

2：将数据包传递到传输层，传输层会对应用层数据包进行进一步的封装，为该数据包添加一个TCP/UDP头部，其中含有源端口号和目的端口号，这样B计算机收到数据后解包传输层数据即知道传输到哪个端口上，因此解决了第一个问题。

3：此时数据到网络层，网络层对数据进一步封装，加上IP地址头，其中含有数据包的源IP和目标IP，数据传输的过程中就是根据这层的目标IP找到需要通信的主机，因此解决了第二个问题。<br>
前三层的数据包很重要，在一个包中称为上三层数据，是最有价值的包，不能被别人篡改，一旦被篡改就有可能造成通信出错或者信息泄露

4：此时数据会到达数据链路层，到达这里的时候就意味着到达网卡了(下一步就可以通过网线传输了)，数据是0 1格式的数据，这里会给数据头部加上MAC子层（含有源MAC地址和目标MAC地址字段，这样能到达B计算机的网卡，有时子网里有多台计算机，那么就是根据mac地址找到对应的网卡的），数据尾部会加上FCS帧校验序列，对中间的信息数据会使用一个循环校验算法，最终得到一个固定的值，我们可以利用这个值和FCS得出这个数据包的内容是否缺失。（数据到达B计算机时也会到达链路层，通过mac找到对应网卡，将数据传输进去）这就解决了第三个问题

5：最后数据到达物理层，通过物理介质如网线、光纤传输出去。这就解决了第四个问题


OSI七层模型和TCP/IP五层模型（在实际的使用中，科学家在每一层中添加对应的协议，发现有其中的表示层和会话层的协议比较少（相对于其他层而言，但也是必不可缺的），于是将这两层合并到应用层，称为TCP/IP五层模型）



#### TCP连接过程 ####

**三次握手**

第一次握手，首先客户端发送SYN包请求报文到服务器，并进入SYN_SEND状态，等待服务端确认

第二次握手，服务端收到请求后需确认客户端的数据包，同时自己也回复SYN+ACK包到客户端，此时服务器进入SYN_RECV状态

第三次握手，客户端收到SYN+ACK包后，再次发送ACK应答报文到服务端，发送完毕后客户端和服务端就进入ESTAB_LISHED已建立连接状态

C(SYN)---->S

C<---------S(SYN+ACK)

C(SYN+ACK)---->S

**四次挥手**

第一次挥手，客户端发送FIN给服务端，告诉服务端关闭客户端与服务端的数据传输，然后进入等待关闭状态

第二次挥手，服务端收到这个FIN，然后给客户端回复一个ACK应答包，告诉客户端收到了，然后继续完成剩余数据传输

第三次挥手，服务端发送一个FIN到客户端，告诉客户端关闭服务端到客户端的连接，然后进入等待关闭状态

第四次挥手，客户端收到FIN后，发回一个ACK应答报文确认，收到后就可以进行关闭了。首先进行关闭的一方进行关闭，另一方进行被动关闭。

C(FIN)---->S

C<---------S(ACK)

C<---------S(FIN)

C(ACK)---->S

握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求




#### HTTP####

**概念**

HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开



#### SOCKET ####

**概念**

socket是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket。

套接字之间的连接过程分为三个步骤：

服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。

客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。

连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。


#### 区别 ####


**TCP/IP和HTTP协议的关系**

TPC/IP协议是传输层协议，主要解决数据 如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据

我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。

http协议是应用层的协义,有个比较形象的描述：HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。两个计算机之间的交流无非是两个端口之间的数据通信,具体的数据会以什么样的形式展现是以不同的应用层协议来定义的,如HTTP FTP



**socket和TCP/IP协议关系**

TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。这个就像操作系统会提供标准的编程接口，比如win32编程接口一样，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。

实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。socket是对端口通信开发的工具,它要更底层一些


**TCP和UDP**

TCP和UDP同属于传输层，共同架设在IP层（网络层）之上。而IP层主要负责的是在节点之间（End to End）的数据包传送，这里的节点是一台网络设备，比如计算机。因为IP层只负责把数据送到节点，而不能区分上面的不同应用，所以TCP和UDP协议在其基础上加入了端口的信息，端口于是标识的是一个节点上的一个应用。除了增加端口信息，UPD协议基本就没有对IP层的数据进行任何的处理了。而TCP协议还加入了更加复杂的传输控制，比如滑动的数据发送窗口（Slice Window），以及接收确认和重发机制，以达到数据的可靠传送。不管应用层看到的是怎样一个稳定的TCP数据流，下面传送的都是一个个的IP数据包，需要由TCP协议来进行数据重组
