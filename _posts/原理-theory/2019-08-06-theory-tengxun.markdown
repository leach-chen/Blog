---
layout: post
title: Tencent
date:  2018-03-20 18:08:00 +0900
description: Tencent
img: post-3.jpg # Add image post (optional)
tags: [原理]
author: # Add name author (optional)

theory: true
#needcomplete: true
---


**热修复**




**增量更新**

1: 使用bsdiff生成差异包PATCH.patch

2: 在手机上合并base包和差异包，生成新版本的安装包

3： 安装新的安装包


**volatile关键字和synchronized的区别**

它所修饰的变量不保留拷贝，直接访问主内存中的。

在Java内存模型中，有main memory，每个线程也有自己的memory (例如寄存器)。为了性能，一个线程会在自己的memory中保持要访问的变量的副本。这样就会出现同一个变 量在某个瞬间，在一个线程的memory中的值可能与另外一个线程memory中的值，或者main memory中的值不一致的情况。 一个变量声明为volatile，就意味着这个变量是随时会被其他线程修改的，因此不能将它cache在线程memory中

保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的

禁止进行指令重排序。<br>
volatile 本质是在告诉 jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取


synchronized修饰一个方法或者代码块，表示同一时刻只能有一个线程访问，其它线程访问到时处于阻塞状态

**synchronized原理**

https://www.jianshu.com/p/e62fa839aa41
https://www.cnblogs.com/mingyao123/p/7424911.html


加上synchronized同步代码块，会在代码块头部加上monitorenter，代码块尾部加上monitorexit，每个对象都有monitor对象与之关联，如果monitor进入数为0，则有线程进入时，则计数会加一，线程会获取monitor的所有权，其它线程进入时则要处于等待状态

同步代码块：monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁

在JVM中，对象在内存中的布局分为三块区域：对象头、实例变量和填充数据。

1： monitorenter：每个对象都是一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：

如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；

如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1；

如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；

2：monitorexit：执行monitorexit的线程必须是objectref所对应的monitor的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。

monitorexit指令出现了两次，第1次为同步正常退出释放锁；第2次为发生异步退出释放锁；


**什么是内存可见性**

一个线程修改了共享变量的值，其它线程也能看到最新修改的值




##常用数据结构##

https://blog.csdn.net/yeyazhishang/article/details/82353846

https://baijiahao.baidu.com/s?id=1609200503642486098&wfr=spider&for=pc

https://www.nowcoder.com/discuss/1799

https://blog.51cto.com/14230003/2411305

**数组**

寻址方便，遍历方便，固定大小后无法扩容，增删麻烦。适用于频繁查询，对存储空间要求不大，很少增加和删除的情况

面试中关于数组的常见问题：

寻找数组中第二小的元素

找到数组中第一个不重复出现的整数

合并两个有序数组

重新排列数组中的正值和负值


**栈**

先进后出，栈底不允许操作，栈顶允许操作。

**队列**

先进先出，一端进入元素，一端取出元素

**链表**

链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现。不需要初始化容量，增删容易，查询慢，适用于数据量较小，需要频繁增加，删除操作的场景

**树**

它是由n个有限节点组成一个具有层次关系的集合。

二叉树：

每个结点最多有两颗子树，左右子树是有序的，即使某个结点只有一个子树，也要区分左右子树。它添加删除元素比较快，查询也有很多优化算法，是数组很链表的优化方案，适用于处理大批量动态数据

二叉树有很多扩展的数据结构，包括平衡二叉树、红黑树、B+树等，这些数据结构二叉树的基础上衍生了很多的功能，在实际应用中广泛用到，例如mysql的数据库索引结构用的就是B+树，还有HashMap的底层源码中用到了红黑树。这些二叉树的功能强大，但算法上比较复杂，想学习的话还是需要花时间去深入的


**散列表**

https://www.nowcoder.com/discuss/1799

散列表也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。

记录的存储位置=f(key)

这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。

哈希表在应用中也是比较常见的，就如Java中有些集合类就是借鉴了哈希原理构造的，例如HashMap，HashTable等，利用hash表的优势，对于集合的查找元素时非常方便的，然而，因为哈希表是基于数组衍生的数据结构，在添加删除元素方面是比较慢的，所以很多时候需要用到一种数组链表来做，也就是拉链法。拉链法是数组结合链表的一种结构，较早前的hashMap底层的存储就是采用这种结构，直到jdk1.8之后才换成了数组加红黑树的结构

**堆**

堆中某个结点的值总是不大于或不小于其父节点的值。堆总是一颗完全二叉树。

**图**

图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构



**HashMap**

hashmap是数组+链表+红黑树组成的数据结构。根据key值进行hash运算得到hash值为一个整数，在Object类中的默认实现是“将该对象的内部地址转换成一个整数返回”，该值与数组长度取余，余数为在数组中的位置。hashmap初始长度为16，可在构造函数中指定初始长度，为2的幂次方，负载因子为0.75，链表长度阀值为8，超过则转为红黑树。还有个解除红黑树的阀值为6，低于该值则会转为链表。
因为hash运算得到的key值可能会发生碰撞，因此引入链表来解决此问题，发生冲突的数据依次添加到链表后面
